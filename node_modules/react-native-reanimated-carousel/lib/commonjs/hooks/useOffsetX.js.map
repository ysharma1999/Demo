{"version":3,"sources":["useOffsetX.ts"],"names":["useOffsetX","opts","visibleRanges","handlerOffset","index","size","loop","dataLength","type","_viewCount","viewCount","ITEM_LENGTH","VALID_LENGTH","TOTAL_WIDTH","HALF_WIDTH","Math","round","positiveCount","startPos","MAX","MIN","x","value","negativeRange","positiveRange","inputRange","Number","MIN_VALUE","outputRange","Extrapolation","CLAMP","MAX_SAFE_INTEGER","interpolate"],"mappings":"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","sourcesContent":["import type Animated from \"react-native-reanimated\";\nimport { Extrapolation, interpolate, useDerivedValue } from \"react-native-reanimated\";\n\nimport type { IVisibleRanges } from \"./useVisibleRanges\";\n\nexport interface IOpts {\n  index: number;\n  size: number;\n  handlerOffset: Animated.SharedValue<number>;\n  dataLength: number;\n  type?: \"positive\" | \"negative\";\n  viewCount?: number;\n  loop?: boolean;\n}\n\nexport const useOffsetX = (opts: IOpts, visibleRanges: IVisibleRanges) => {\n  const {\n    handlerOffset,\n    index,\n    size,\n    loop,\n    dataLength,\n    type = \"positive\",\n    viewCount: _viewCount,\n  } = opts;\n\n  const ITEM_LENGTH = dataLength;\n  const VALID_LENGTH = ITEM_LENGTH - 1;\n  const TOTAL_WIDTH = size * ITEM_LENGTH;\n  const HALF_WIDTH = 0.5 * size;\n\n  const viewCount = _viewCount ?? Math.round((ITEM_LENGTH - 1) / 2);\n  const positiveCount = type === \"positive\" ? viewCount : VALID_LENGTH - viewCount;\n\n  let startPos = size * index;\n  if (index > positiveCount) startPos = (index - ITEM_LENGTH) * size;\n\n  const MAX = positiveCount * size;\n  const MIN = -((VALID_LENGTH - positiveCount) * size);\n\n  const x = useDerivedValue(() => {\n    const { negativeRange, positiveRange } = visibleRanges.value;\n\n    if (\n      (index >= negativeRange[0] && index <= negativeRange[1]) ||\n      (index >= positiveRange[0] && index <= positiveRange[1])\n    ) {\n      if (loop) {\n        const inputRange = [\n          -TOTAL_WIDTH,\n          MIN - HALF_WIDTH - startPos - Number.MIN_VALUE,\n          MIN - HALF_WIDTH - startPos,\n          0,\n          MAX + HALF_WIDTH - startPos,\n          MAX + HALF_WIDTH - startPos + Number.MIN_VALUE,\n          TOTAL_WIDTH,\n        ];\n\n        const outputRange = [\n          startPos,\n          MAX + HALF_WIDTH - Number.MIN_VALUE,\n          MIN - HALF_WIDTH,\n          startPos,\n          MAX + HALF_WIDTH,\n          MIN - HALF_WIDTH + Number.MIN_VALUE,\n          startPos,\n        ];\n\n        return interpolate(handlerOffset.value, inputRange, outputRange, Extrapolation.CLAMP);\n      }\n\n      return handlerOffset.value + size * index;\n    }\n\n    return Number.MAX_SAFE_INTEGER;\n  }, [loop, dataLength, viewCount, type, size, visibleRanges, handlerOffset]);\n\n  return x;\n};\n"]}