{"version":3,"sources":["useCommonVariables.ts"],"names":["useCommonVariables","props","vertical","height","width","dataLength","defaultIndex","defaultScrollOffsetValue","loop","size","defaultHandlerOffsetValue","Math","abs","_handlerOffset","handlerOffset","prevDataLength","prevSize","previousLength","value","currentLength","isLengthChanged","shouldComputed","direction","handlerOffsetDirection","computeOffsetIfDataChanged","previousSize","isSizeChanged","computeOffsetIfSizeChanged","validLength"],"mappings":"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","sourcesContent":["import type Animated from \"react-native-reanimated\";\nimport { useAnimatedReaction, useSharedValue } from \"react-native-reanimated\";\n\nimport type { TInitializeCarouselProps } from \"./useInitProps\";\n\nimport { computeOffsetIfDataChanged } from \"../utils/compute-offset-if-data-changed\";\nimport { computeOffsetIfSizeChanged } from \"../utils/compute-offset-if-size-changed\";\nimport { handlerOffsetDirection } from \"../utils/handleroffset-direction\";\n\ninterface ICommonVariables {\n  size: number;\n  validLength: number;\n  handlerOffset: Animated.SharedValue<number>;\n}\n\nexport function useCommonVariables(props: TInitializeCarouselProps<any>): ICommonVariables {\n  const { vertical, height, width, dataLength, defaultIndex, defaultScrollOffsetValue, loop } =\n    props;\n  const size = vertical ? height : width;\n  const defaultHandlerOffsetValue = -Math.abs(defaultIndex * size);\n  const _handlerOffset = useSharedValue<number>(defaultHandlerOffsetValue);\n  const handlerOffset = defaultScrollOffsetValue ?? _handlerOffset;\n  const prevDataLength = useSharedValue(dataLength);\n  const prevSize = useSharedValue(size);\n\n  /**\n   * When data changes, we need to compute new index for handlerOffset\n   */\n  useAnimatedReaction(\n    () => {\n      const previousLength = prevDataLength.value;\n      const currentLength = dataLength;\n      const isLengthChanged = previousLength !== currentLength;\n      const shouldComputed = isLengthChanged && loop;\n\n      if (shouldComputed) prevDataLength.value = dataLength;\n\n      return {\n        shouldComputed,\n        previousLength,\n        currentLength,\n      };\n    },\n    ({ shouldComputed, previousLength, currentLength }) => {\n      if (shouldComputed) {\n        // direction -> 1 | -1\n        const direction = handlerOffsetDirection(handlerOffset);\n\n        handlerOffset.value = computeOffsetIfDataChanged({\n          direction,\n          previousLength,\n          currentLength,\n          size,\n          handlerOffset: handlerOffset.value,\n        });\n      }\n    },\n    [dataLength, loop]\n  );\n\n  /**\n   * When size changes, we need to compute new index for handlerOffset\n   */\n  useAnimatedReaction(\n    () => {\n      const previousSize = prevSize.value;\n      const isSizeChanged = previousSize !== size;\n      const shouldComputed = isSizeChanged;\n\n      if (shouldComputed) prevSize.value = size;\n\n      return {\n        shouldComputed,\n        previousSize,\n        size,\n      };\n    },\n    ({ shouldComputed, previousSize, size }) => {\n      if (shouldComputed) {\n        handlerOffset.value = computeOffsetIfSizeChanged({\n          handlerOffset: handlerOffset.value,\n          prevSize: previousSize,\n          size,\n        });\n      }\n    },\n    [size]\n  );\n\n  return {\n    size,\n    validLength: dataLength - 1,\n    handlerOffset,\n  };\n}\n"]}