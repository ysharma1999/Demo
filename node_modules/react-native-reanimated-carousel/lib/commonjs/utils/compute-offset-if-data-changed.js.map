{"version":3,"sources":["compute-offset-if-data-changed.ts"],"names":["omitZero","a","b","computeOffsetIfDataChanged","params","direction","_handlerOffset","handlerOffset","size","previousLength","currentLength","positionIndex","round","isPositive","Math","abs","Number","parseInt","String","prevOffset","prevIndex","changedLength","changedOffset"],"mappings":"6rBAAgBA,CAAAA,Q,CAAT,4EAAkBC,CAAlB,CAA6BC,CAA7B,CAAwC,CAE7C,GAAID,CAAC,GAAK,CAAV,CAAa,MAAO,EAAP,CAEb,MAAOC,CAAAA,CAAP,CACD,CALM,6J,moFAOSC,CAAAA,0B,CAAT,iHAAoCC,MAApC,CAMJ,CAED,GAAQC,CAAAA,SAAR,CAA0FD,MAA1F,CAAQC,SAAR,CAAkCC,cAAlC,CAA0FF,MAA1F,CAAmBG,aAAnB,CAAkDC,IAAlD,CAA0FJ,MAA1F,CAAkDI,IAAlD,CAAwDC,cAAxD,CAA0FL,MAA1F,CAAwDK,cAAxD,CAAwEC,aAAxE,CAA0FN,MAA1F,CAAwEM,aAAxE,CAEA,GAAIH,CAAAA,aAAa,CAAGD,cAApB,CACA,GAAIK,CAAAA,aAAJ,CACA,GAAIC,CAAAA,KAAJ,CAEA,GAAMC,CAAAA,UAAU,CAAGR,SAAS,CAAG,CAA/B,CAEA,GAAIQ,UAAJ,CAAgB,CACdF,aAAa,CAAGG,IAAI,CAACC,GAAL,CAASR,aAAT,EAA0BC,IAA1C,CACAI,KAAK,CAAGI,MAAM,CAACC,QAAP,CAAgBC,MAAM,CAAClB,QAAQ,CAACS,cAAD,CAAiBE,aAAa,CAAGF,cAAjC,CAAT,CAAtB,CAAR,CACD,CAHD,IAGO,CACLE,aAAa,CAAG,CAACG,IAAI,CAACC,GAAL,CAASR,aAAT,EAA0BC,IAA3B,EAAmCA,IAAnD,CACAI,KAAK,CAAGI,MAAM,CAACC,QAAP,CAAgBC,MAAM,CAAClB,QAAQ,CAACS,cAAD,CAAiBE,aAAa,CAAGF,cAAjC,CAAT,CAAtB,EAAoF,CAA5F,CACD,CAED,GAAMU,CAAAA,UAAU,CAAGnB,QAAQ,CAACS,cAAD,CAAiBE,aAAa,CAAGF,cAAjC,CAA3B,CACA,GAAMW,CAAAA,SAAS,CAAGP,UAAU,CAAGM,UAAH,CAAgBV,cAAc,CAAGU,UAAjB,CAA8B,CAA1E,CACA,GAAME,CAAAA,aAAa,CAAGT,KAAK,EAAIF,aAAa,CAAGD,cAApB,CAA3B,CACA,GAAMa,CAAAA,aAAa,CAAGD,aAAa,CAAGb,IAAtC,CACA,GAAIY,SAAS,CAAGV,aAAa,CAAG,CAA5B,EAAiCA,aAAa,CAAGD,cAArD,CAAqE,CACnE,GAAII,UAAJ,CAAgBN,aAAa,CAAG,CAACG,aAAa,CAAG,CAAjB,EAAsBF,IAAtB,CAA6BH,SAA7C,CAAhB,IACKE,CAAAA,aAAa,CAAG,CAACG,aAAa,CAAG,CAAjB,EAAsBF,IAAtB,CAA6B,CAAC,CAA9C,CACN,CAHD,IAGO,CACLD,aAAa,EAAIe,aAAa,CAAGjB,SAAjC,CACD,CAED,MAAOE,CAAAA,aAAP,CACD,CApCM,gDAkB4BP,QAlB5B,gN","sourcesContent":["export function omitZero(a: number, b: number) {\n  \"worklet\";\n  if (a === 0) return 0;\n\n  return b;\n}\n\nexport function computeOffsetIfDataChanged(params: {\n  direction: number;\n  handlerOffset: number;\n  size: number;\n  previousLength: number;\n  currentLength: number;\n}) {\n  \"worklet\";\n  const { direction, handlerOffset: _handlerOffset, size, previousLength, currentLength } = params;\n\n  let handlerOffset = _handlerOffset;\n  let positionIndex: number;\n  let round: number;\n\n  const isPositive = direction < 0;\n\n  if (isPositive) {\n    positionIndex = Math.abs(handlerOffset) / size;\n    round = Number.parseInt(String(omitZero(previousLength, positionIndex / previousLength)));\n  } else {\n    positionIndex = (Math.abs(handlerOffset) - size) / size;\n    round = Number.parseInt(String(omitZero(previousLength, positionIndex / previousLength))) + 1;\n  }\n\n  const prevOffset = omitZero(previousLength, positionIndex % previousLength);\n  const prevIndex = isPositive ? prevOffset : previousLength - prevOffset - 1;\n  const changedLength = round * (currentLength - previousLength);\n  const changedOffset = changedLength * size;\n  if (prevIndex > currentLength - 1 && currentLength < previousLength) {\n    if (isPositive) handlerOffset = (currentLength - 1) * size * direction;\n    else handlerOffset = (currentLength - 1) * size * -1;\n  } else {\n    handlerOffset += changedOffset * direction;\n  }\n\n  return handlerOffset;\n}\n"]}